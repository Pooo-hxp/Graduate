<!DOCTYPE html>
<html>
<head>
<title>readme.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<blockquote>
<blockquote>
<p>`</p>
<blockquote>
<blockquote>
<blockquote>
<h2 id="%E5%85%B3%E4%BA%8Evue-30">关于Vue 3.0</h2>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h4 id="%E5%89%8D%E8%A8%80">前言：</h4>
<ul>
<li>正式版：<code>Vue</code>团队于2020.09.18日发布3.0正式版</li>
<li>前置条件：<code>Vue</code>虽然保留了大量的2.0版本<code>api</code>,但由于是使用<code>TypeScript</code>重构，所以想要学习3.0起码要掌握<code>TS</code>的基础使用</li>
</ul>
<p><strong>Vue3.0中的六大亮点</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">特性</th>
<th style="text-align:left">解析</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><code>Performance </code></td>
<td style="text-align:left">性能上比Vue2.0快1.3~2倍</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><code>Tree shaking support </code></td>
<td style="text-align:left">按需编译，体积更加轻量化</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><code>Composition API</code></td>
<td style="text-align:left">组合API，可参考<code>React hooks</code>理解</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><code>Better TypeScript support</code></td>
<td style="text-align:left">对 Ts 提供了更好的支持</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><code>Custom Renderer API</code></td>
<td style="text-align:left">暴露了自定义渲染API</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><code>Fragment,Teleport(Protal),Suspense</code></td>
<td style="text-align:left">更先进的组件</td>
</tr>
</tbody>
</table>
<p>注：具体可以参考<code>github</code>中<code>Vue3.0</code>的相关源文件<code>https://github.com/vuejs/vue-next/tree/master/packages</code></p>
<hr>
<h3 id="vue30%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E6%9B%B4%E8%BD%BB%E9%87%8F%E6%9B%B4%E5%BF%AB%E7%9A%84">Vue3.0是基于什么优化，如何做到更轻量，更快的？</h3>
<ul>
<li>一 、diff 算法优化
<ul>
<li>Vue 2中的虚拟Dom是全量比较</li>
<li>Vue 3新增静态标记（PatchFlag）</li>
<li>在与数据变化后，与上次虚拟DOM节点比较时，只比较带有PatchFlag标记的节点</li>
<li>并且可以从flag信息中得知具体需要比较的内容。</li>
</ul>
</li>
</ul>
<blockquote>
<p>静态标记就是非全量比较，只会比较那些被标记的变量，比较的数量大大减少因此提升性能</p>
<blockquote>
<p>这让我想到了JS垃圾回收机制里的标记清除，ORZ 感觉熟悉，但回收机是全标记只是清除具有离开环境的标记变量而已）</p>
<blockquote>
<p><strong>内存垃圾回收机制在我去年的博文中👉<a href="https://www.xipengheng.cn/?p=321">点击</a></strong>
比如下面这个示例</p>
</blockquote>
</blockquote>
</blockquote>
<pre class="hljs"><code><div>    &lt;div&gt;
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>土豆哇~ <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>静态文本<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{msg}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
    &lt;<span class="hljs-regexp">/div&gt;
 /</span><span class="hljs-regexp">/------------在下方编译中可以清晰看到标记--------------------
</span></div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>{
  <span class="hljs-keyword">return</span> (_openBlock(), _createBlock(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [
    _createVNode(<span class="hljs-string">"a"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">" 土豆哇~ "</span>),
    _createVNode(<span class="hljs-string">"p"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"静态文本"</span>),
    _createVNode(<span class="hljs-string">"p"</span>, <span class="hljs-literal">null</span>, _toDisplayString(_ctx.msg), <span class="hljs-number">1</span> <span class="hljs-comment">/* text文本在这里标记为1 */</span>)
  ]))
}
<span class="hljs-comment">//编译网址---&gt;  https://vue-next-template-explorer.netlify.app/</span>
</div></code></pre>
<ul>
<li>由以上可得知：
<ul>
<li>在vue2.0中对于数据变化后重新渲染的DOM树，会与上次渲染的DOM树逐个比较节点</li>
<li>在vue3.0的diff中，创建虚拟DOM时，会根据该DOM是否会变化而添加静态标记，数据更新需要生成新的虚拟DOM时，只会与上次渲染的且被标记的节点比较。</li>
<li>不同的动态变化类型，为了便于区分，标记的数值也不同</li>
<li>因此在vue3.0中比较次数更少，效率更高，速度更快。</li>
</ul>
</li>
</ul>
<h4 id="%E7%A4%BA%E4%BE%8B"><strong>示例</strong></h4>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>{
  <span class="hljs-keyword">return</span> (_openBlock(), _createBlock(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [
    _createVNode(<span class="hljs-string">"a"</span>, { <span class="hljs-attr">id</span>: _ctx.Poo }, <span class="hljs-string">" 土豆哇~ "</span>, <span class="hljs-number">8</span> <span class="hljs-comment">/* PROPS */</span>, [<span class="hljs-string">"id"</span>]),
    _createVNode(<span class="hljs-string">"p"</span>, { <span class="hljs-attr">class</span>: _ctx.style }, <span class="hljs-string">" 静态文本"</span>, <span class="hljs-number">2</span> <span class="hljs-comment">/* CLASS */</span>),
    _createVNode(<span class="hljs-string">"p"</span>, <span class="hljs-literal">null</span>, _toDisplayString(_ctx.msg), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>)
  ]))
}
</div></code></pre>
<h4 id="%E6%A0%87%E8%AE%B0%E6%9F%A5%E8%AF%A2%E5%88%97%E8%A1%A8"><strong>标记查询列表</strong></h4>
<pre class="hljs"><code><div>  TEXT = <span class="hljs-number">1</span>,<span class="hljs-comment">// --取值是1---表示具有动态textContent的元素</span>
  CLASS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,  <span class="hljs-comment">// --取值是2---表示有动态Class的元素</span>
  STYLE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,  <span class="hljs-comment">// --取值是4---表示动态样式（静态如style="color: pink"，也会提升至动态）</span>
  PROPS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>,  <span class="hljs-comment">// --取值是8--- 表示具有非类/样式动态道具的元素。</span>
  FULL_PROPS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>,  <span class="hljs-comment">// --取值是16---表示带有动态键的道具的元素，与上面三种相斥</span>
  HYDRATE_EVENTS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>,  <span class="hljs-comment">// --取值是32---表示带有事件监听器的元素</span>
  STABLE_FRAGMENT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>,   <span class="hljs-comment">// --取值是64---表示其子顺序不变，不会改变自顺序的片段。 </span>
  KEYED_FRAGMENT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>, <span class="hljs-comment">// --取值是128---表示带有键控或部分键控子元素的片段。</span>
  UNKEYED_FRAGMENT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>, <span class="hljs-comment">// --取值是256---子节点无key绑定的片段（fragment）</span>
  NEED_PATCH = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">9</span>,   <span class="hljs-comment">// --取值是512---表示只需要非属性补丁的元素，例如ref或hooks</span>
  DYNAMIC_SLOTS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>,  <span class="hljs-comment">// --取值是1024---表示具有动态插槽的元素</span>
</div></code></pre>
<ul>
<li>二 、hoistStatic  静态提升
<ul>
<li>vue2.0中，在更新时，元素即使没有变化，也会重新创建进行渲染</li>
<li>vue3.0中，不参与更新的元素；会静态提升，只创建一次下次渲染直接复用。</li>
<li>因此在vue3.0中复用更多，创建次数更少，速度更快。见下方示例：</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    &lt;div&gt;
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>土豆哇~ <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>静态文本<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{msg}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">'https://vue-next-template-explorer.netlify.app/'</span>&gt;</span>vue3.0编译地址<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>
    &lt;<span class="hljs-regexp">/div&gt;
</span></div></code></pre>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
     * 在下方编译中(在options中勾选hoistStatic)进行静态提升,
     * 可以清晰看到不更新元素未参与重新创建
    */</span>
<span class="hljs-keyword">const</span> _hoisted_1 = <span class="hljs-comment">/*#__PURE__*/</span>_createVNode(<span class="hljs-string">"a"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"土豆哇~ "</span>, <span class="hljs-number">-1</span> <span class="hljs-comment">/* HOISTED */</span>)

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>{
  <span class="hljs-keyword">return</span> (_openBlock(), _createBlock(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [
    _hoisted_1,
    _createVNode(<span class="hljs-string">"p"</span>, { <span class="hljs-attr">style</span>: _ctx.myStyle }, <span class="hljs-string">"静态文本"</span>, <span class="hljs-number">4</span> <span class="hljs-comment">/* STYLE */</span>),
    _createVNode(<span class="hljs-string">"p"</span>, <span class="hljs-literal">null</span>, _toDisplayString(_ctx.msg), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>),
    _createVNode(<span class="hljs-string">"a"</span>, {
      <span class="hljs-attr">style</span>: _ctx.myStyle,
      <span class="hljs-attr">href</span>: <span class="hljs-string">"https://vue-next-template-explorer.netlify.app/"</span>
    }, <span class="hljs-string">"vue3.0编译地址"</span>, <span class="hljs-number">4</span> <span class="hljs-comment">/* STYLE */</span>)
  ]))
}
}
</div></code></pre>
<ul>
<li>三、cachehandlers 事件侦听缓存
<ul>
<li>onClick默认视为动态绑定，因此会追踪它的变化</li>
<li>事件绑定的函数为同一个，因此不追踪它的变化，直接缓存后进行复用</li>
<li>同样的，我在编译中进行演示</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    &lt;div&gt;
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">'Pooo'</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
    &lt;<span class="hljs-regexp">/div&gt;
</span></div></code></pre>
<pre class="hljs"><code><div>    <span class="hljs-comment">/**
     * 开启事件侦听缓存前：
     * 下方为常规编译后，可以看到静态标记为8
     * 既然有静态标记，那么它就会进行比较
    */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>{
  <span class="hljs-keyword">return</span> (_openBlock(), _createBlock(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [
    _createVNode(<span class="hljs-string">"button"</span>, { <span class="hljs-attr">onClick</span>: _ctx.Pooo }, <span class="hljs-string">"按钮"</span>, <span class="hljs-number">8</span> <span class="hljs-comment">/* PROPS */</span>, [<span class="hljs-string">"onClick"</span>])
  ]))
}
</div></code></pre>
<h4 id="%E7%84%B6%E5%90%8E%E6%88%91%E5%9C%A8options%E4%B8%AD%E6%89%93%E5%BC%80%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E7%BC%93%E5%AD%98cachehandlers"><strong>然后我在options中打开事件侦听缓存（cachehandlers）</strong></h4>
<pre class="hljs"><code><div><span class="hljs-comment">/**
 * 可以发现打开侦听缓存后，没有静态标记
 * 在diff算法中，没有静态标记的是不会进行比较和进行追踪的
*/</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>{
  <span class="hljs-keyword">return</span> (_openBlock(), _createBlock(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, [
    _createVNode(<span class="hljs-string">"button"</span>, {
      <span class="hljs-attr">onClick</span>: _cache[<span class="hljs-number">1</span>] || <span class="hljs-function">(<span class="hljs-params">_cache[<span class="hljs-number">1</span>] = (...args</span>) =&gt;</span> (_ctx.Pooo(...args)))
    }, <span class="hljs-string">"按钮"</span>)
  ]))
}
</div></code></pre>
<h4 id="%E4%BD%BF%E7%94%A8vue30%E6%8F%90%E4%BE%9B%E7%9A%84vite%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><strong>使用vue3.0提供的Vite快速创建项目</strong></h4>
<ul>
<li>Vite是Vue作者开发的一款意图取代webpack的工具</li>
<li>原理是利用ES6的import发送请求加载文件的特性，进而拦截，然后做预编译，省去webpack冗长的打包</li>
<li>使用步骤
<ul>
<li>安装Vite命令： <code>npm install -g create-vite-app</code></li>
<li>创建Vue3项目： <code>create-vite-app PoooName</code></li>
<li>安装依赖：<code>cd PoooName / npm install / npm run dev</code></li>
<li>Vue3.0中兼容2.0的写法，具体代码在此文件同级的PoooName项目文件中</li>
</ul>
</li>
</ul>
<h4 id="vue30%E4%B8%AD%E7%9A%84-reactive-%E7%94%A8%E6%B3%95"><strong>vue3.0中的 reactive 用法</strong></h4>
<ul>
<li>在2.0中对于业务实现</li>
<li>需要先在data中变更补充数据，然后在<code>methods</code>或<code>watch</code>中补充业务逻辑</li>
<li>这样数据和逻辑是分模块的，查找不便，不利于业务的管理和维护</li>
<li>为解决这样的问题，Vue3.0中加入了 <code>reactive</code></li>
<li>Vue3.0提供了setup 组合API的入口函数，可以把数据和业务逻辑组合在一起</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>; <span class="hljs-comment">//在Vue3.0使用中需要引入reactive</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"App"</span>,
  <span class="hljs-comment">//Vue3.0提供了setup 组合API的入口函数</span>
  setup() {
    <span class="hljs-comment">/**
     * ref一般用来监听简单类型变化（也可以用来监听复杂类型变化,先不讨论）
     * 通常使用reactive用来监听复杂类型变化（比如数组、函数之类）
     * 以下为一种常规的写法
     */</span>
    <span class="hljs-keyword">let</span> stus = reactive({ <span class="hljs-attr">stusList</span>: [****its data****], });
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeVeget</span>(<span class="hljs-params">index</span>) </span>{
      stus.stusList.splice(index, <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">return</span> { stus, removeVeget };<span class="hljs-comment">// 必须暴露出去，组件中才可以使用</span>
  },
  <span class="hljs-attr">methods</span>: {},
};
</div></code></pre>
<ul>
<li>另一种更加优雅的写法，也是<strong>非常非常</strong>推荐的写法是</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>; 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"App"</span>,
  setup() {
    <span class="hljs-keyword">let</span> {stus, removeVeget }=removeItem();<span class="hljs-comment">// 三、直接声明、获取</span>
    <span class="hljs-keyword">return</span> { stus, removeVeget };<span class="hljs-comment">//四、暴露给外界组件使用</span>
  },
  <span class="hljs-attr">methods</span>: {},
};
    <span class="hljs-comment">/**
     * 保证数据和业务不分散利于更新维护
     * 也避免了setup中的大量数据函数填充
     * 也不需要使用this指向Vue实例
    */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeItem</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> stus = reactive({ <span class="hljs-attr">stusList</span>: [****its data****], });
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeVeget</span>(<span class="hljs-params">index</span>) </span>{
      stus.stusList.splice(index, <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">return</span> {stus,removeVeget} <span class="hljs-comment">// 二、暴露给组合API使用</span>
  }
</div></code></pre>
<ul>
<li>功能分离：
<ul>
<li>乍一看上方把函数整合到下方，然后在<code>setup</code>中引用是很简洁</li>
<li>若需要的业务功能多了呢，比如增加个<code>updateItem</code>,<code>addItem</code></li>
<li>虽然数据和逻辑代码还是在一块，但是各种功能聚集在一块还是显得文件臃肿</li>
<li>那么还要继续优化，分离各个功能
<ol>
<li>新建一个单独的JS文件，如remove.js</li>
<li>在APP文件中引入这个JS文件
3.这样就可以在单独的JS文件中对某个功能进行维护了</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>; <span class="hljs-comment">//引入依赖</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeItem</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-comment">//定义函数，实现功能</span>
  <span class="hljs-keyword">let</span> stus = reactive({
    <span class="hljs-attr">stusList</span>: [
      { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">Name</span>: <span class="hljs-string">"potato"</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">"2.5"</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">Name</span>: <span class="hljs-string">"tomato"</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">"3.5"</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">Name</span>: <span class="hljs-string">"cucumber"</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">"4.5"</span> },
    ],
  });
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeVeget</span>(<span class="hljs-params">index</span>) </span>{
    stus.stusList.splice(index, <span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">return</span> {stus,removeVeget} 
}
<span class="hljs-keyword">export</span>  {removeItem};<span class="hljs-comment">//暴露给外界使用</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">/*那么主文件就变成了如下形式（单独JS文件中已经引入reactive）*/</span>
<span class="hljs-keyword">import</span> { removeItem } <span class="hljs-keyword">from</span> <span class="hljs-string">"./remove"</span>; <span class="hljs-comment">//导入删除的业务逻辑模块</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
<span class="hljs-attr">name</span>: <span class="hljs-string">"App"</span>,
setup() {
  <span class="hljs-keyword">let</span> { stus, removeVeget } = removeItem();
  <span class="hljs-keyword">return</span> { stus, removeVeget };
},
<span class="hljs-attr">methods</span>: {},
};
</div></code></pre>
<h4 id="vue30%E4%B8%AD%E7%9A%84-composition-api%E6%9C%AC%E8%B4%A8"><strong>vue3.0中的 Composition API本质</strong></h4>
<ul>
<li>Option API：即在APP中为实现业务逻辑进行的配置
<ul>
<li>在2.0中比如你要实现一个点击按钮，弹出提示语功能，你需要
<ol>
<li>利用 <code>Opaction API</code></li>
<li>在 <code>data</code> 中配置数据</li>
<li>在 <code>methods</code> 中配置相应函数</li>
</ol>
</li>
<li>在3.0中通过上方 <code>reactive</code> 的知识点我们知道，实现这个功能，你需要
<ol>
<li>利用 <code>Composition API</code></li>
<li>在 <code>setup</code> 中定义数据，编写函数</li>
<li>通过 <code>return{ 数据,方法}</code>暴露出去</li>
</ol>
</li>
<li>其实 <code>Composition</code> (也叫注入API)本质是在运行时
<ol>
<li>把暴露出来的数据注入到 <code>opaction</code> 中的 <code>data</code></li>
<li>把暴露出来的函数注入到 <code>opaction</code> 中的 <code>methods</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注: 具体它咋区分数据还是函数用以注入到相应配置中的，我也不知道（ <strong><s>标志位or传参顺序？</s></strong> ）</p>
</blockquote>
<ul>
<li>小结：
<ul>
<li><code>Opaction API</code>中对配置项都进行了规定，比如：
<ul>
<li>在data中配置数据，methods中编写方法， <code>watch </code>中进行监听。</li>
<li>保姆式的分配较为清晰，但也对代码层层分割，维护要扒拉半天跳来跳</li>
</ul>
</li>
<li><code>Composition</code>中更加自由，比如：
<ul>
<li>不用担心各种this指向</li>
<li>随意进行模块分割导出，维护时查找固定模块文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E7%9A%84-setup"><strong>生命周期中的 setup</strong></h4>
<ul>
<li><strong>setup的执行时机在<code>beforeCreate</code>和<code>created</code>之前，前前前</strong>
<ul>
<li>这其实根据上方总结的内容，用屁股也能想出来原因</li>
<li>在Vue生命周期中我们知道：
<ol>
<li><code>beforeCreate </code>时，刚初始化一个空 <code>Vue </code>实例对象， <code>data </code>和 <code>methods </code>中数据 <strong>未初始化</strong></li>
<li><code>created </code>执行时，data和methods已经<strong>初始化完毕</strong></li>
<li><code>Composition</code> 需要把setup中的数据对应注入到 <code>data </code>和 <code>methods </code>中去</li>
<li>很显然setup必须要在 <code>created </code>之前执行</li>
</ol>
</li>
<li>也因此，若你在Vue3.0中进行混合开发，不可以在 <code>setup </code>中使用 <code>data </code>中的数据和 <code>methods </code>中的方法</li>
<li>在3.0中<code>setup </code>里的this也被修改为了<code>undefiend</code></li>
<li>在3.0中<code>setup </code>里也不可以使用异步</li>
<li>（下方贴的图我也加入了旁释，可帮助你回想下生命周期）
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd4270cf4ae6499fa790cc813433eea5~tplv-k3u1fbpfcp-watermark.image" alt=""></li>
</ul>
</li>
</ul>
<h4 id="%E4%BB%80%E4%B9%88%E6%98%AF-reactive"><strong>什么是 reactive</strong></h4>
<ul>
<li><code>reactive</code>是<code>VUE3.0</code>中提供的实现响应式数据的方法</li>
<li>在Vue2.0中使用的是<code>defineProperty</code>来实现的（我自己也手动实现过👉 <a href="https://www.xipengheng.cn/?paged=2&amp;cat=69">点击</a>）</li>
<li>而<code>VUE3.0</code>中使用的是ES6里的<code>proxy</code>实现的</li>
<li><code>reactive</code>中需要注意的点：
<ul>
<li>传递给它的类型必须是对象（JSON或者arr数组）</li>
<li>并且它会自动把传递进来条件再赋值给<code>Proxy</code>对象</li>
<li>若传递的为上述以外的对象
<ol>
<li>在方法中直接修改它，界面上它也不会自动更新</li>
<li>若想更新只能通过重新赋值的方式</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-comment">/*示例如下*/</span>
  setup() {
    <span class="hljs-keyword">let</span> testJson=reactive({
      <span class="hljs-attr">tip</span>:<span class="hljs-string">'its a Json！'</span>
    })
    <span class="hljs-keyword">let</span> testArray=reactive([<span class="hljs-string">'first'</span>,<span class="hljs-string">'second'</span>,<span class="hljs-string">'third'</span>])
    <span class="hljs-keyword">let</span> testString=reactive(<span class="hljs-string">'Just a string'</span>)
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showProxyPar</span>(<span class="hljs-params"></span>)</span>{
      testJson.tip=<span class="hljs-string">'changed'</span>;
      testArray[<span class="hljs-number">2</span>]=<span class="hljs-string">'selected'</span>;
      testString=<span class="hljs-string">'hengxipeng'</span>;<span class="hljs-comment">//由于不是对象，所以即使更改视图也不会同步更新</span>
      <span class="hljs-built_in">console</span>.log(testJson);<span class="hljs-comment">// Proxy {tip: "changed"}</span>
      <span class="hljs-built_in">console</span>.log(testArray);<span class="hljs-comment">// Proxy {0: "first", 1: "second", 2: "selected"}</span>
      <span class="hljs-built_in">console</span>.log(testString);<span class="hljs-comment">// hengxipeng</span>
    }
    <span class="hljs-keyword">return</span> { testJson,testArray,testString,showProxyPar };
  },
</div></code></pre>
<ul>
<li>效果正如下图所示，符合传递条件的参数会再赋值给Proxy，并且修改它也会直接影响视图
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ed8d67f20454398b683ef68254555a1~tplv-k3u1fbpfcp-watermark.image" alt=""></li>
</ul>
<h4 id="%E4%BB%80%E4%B9%88%E6%98%AF-ref"><strong>什么是 ref</strong></h4>
<ul>
<li>它也是实现响应式数据的方法</li>
<li><code>reactivce</code>向来都是进行传递对象，实际开发中若只想更改某简单变量则会显得大材小用</li>
<li>所以<code>vue3</code>提供了<code>ref</code>方法，来实现对简单值的监听</li>
<li><code>ref</code>本质也是使用<code>reactive</code>，给<code>ref</code>的赋值，它底层会自动转化</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-comment">/**
   * 实质是 ref('its a string')==&gt;reactive({value:'its a string'})
   * 也因此更改时应该 testRef.value=XX 才能更改
   * （使用的时候不必再加 value，直接使用即可）
   */</span>
  setup() {
    <span class="hljs-keyword">let</span> testRef = ref(<span class="hljs-string">'its a string'</span>);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showProxyPar</span>(<span class="hljs-params"></span>) </span>{
      testRef.value=<span class="hljs-string">'ref_string'</span>
      <span class="hljs-built_in">console</span>.log(testRef);
    }
    <span class="hljs-keyword">return</span> { testRef, showProxyPar };
  },
</div></code></pre>
<ul>
<li>如下图</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd9fd7eedcc34092a523d445bbc21595~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h4 id="ref-%E5%92%8C-reactive-%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%8D%E5%90%8C"><strong>ref 和 reactive 之间的不同</strong></h4>
<ul>
<li>通过以上得知，使用<code>ref</code>其实相当于使用<code>reactive</code>，只是省略了手动创建对象的步骤</li>
<li><code>ref</code>中底层会添加一个<code>value</code>的键，并且在视图中可省略调用<code>value</code>
<ul>
<li>经过我自己测试
<ol>
<li>使用<code>reactive</code>，创建一个键值为<code>value</code>的<code>Json</code>对象，验证是否可省略<code>value</code>调用（<strong>不可以</strong>）</li>
<li>得知，只有使用<code>ref</code>传递参数时，视图才允许省略<code>value</code>调用</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-comment">/**
   * Vue在解析时，通过  __v_isRef 来判定当前参数是否由 ref 传递出来的
   * 是的话，则会自动在调用当前参数时添加 value
   */</span>
      <span class="hljs-attr">__v_isRef</span>: <span class="hljs-literal">true</span>
      <span class="hljs-attr">_rawValue</span>: <span class="hljs-string">"its a string"</span>
      <span class="hljs-attr">_shallow</span>: <span class="hljs-literal">false</span>
      <span class="hljs-attr">_value</span>: <span class="hljs-string">"its a string"</span>
      <span class="hljs-attr">value</span>: <span class="hljs-string">"its a string"</span>
</div></code></pre>
<ul>
<li>其中<code>Vue3.0</code>中提供了两个方法，<code>isReactive</code>和<code>isRef</code>用来判定数据来源</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> {isRef,isReactive } <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;
  setup() {
    <span class="hljs-keyword">let</span> testReactive = reactive({<span class="hljs-attr">value</span>:<span class="hljs-string">'its a string'</span>});
    <span class="hljs-keyword">let</span> testRef = ref(<span class="hljs-string">'its a string'</span>);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showProxyPar</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'检测是否是Ref'</span>,isRef(testReactive));<span class="hljs-comment">// false</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'检测是否是Ref'</span>,isRef(testRef));<span class="hljs-comment">// true</span>
    }
    <span class="hljs-keyword">return</span> { testRef,testReactive, showProxyPar };
  }
</div></code></pre>
<h4 id="%E9%80%92%E5%BD%92%E7%9B%91%E5%90%AC"><strong>递归监听</strong></h4>
<ul>
<li>通常情况下<code>ref</code>和<code>reactive</code>都会监听数据变化</li>
</ul>
<blockquote>
<p>验证如下，点击按钮触发<code>recursion</code> 页面显示都会改变</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">//验证ref 只需添加value即可，如： parse.value.type='fruit';</span>
  setup() {
    <span class="hljs-keyword">let</span> parse = reactive({
      <span class="hljs-attr">type</span>: <span class="hljs-string">"vegetables"</span>,
      <span class="hljs-attr">suchAS</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"tomato"</span>,
        <span class="hljs-attr">info</span>: {
          <span class="hljs-attr">price</span>: <span class="hljs-string">"0.4元/kg"</span>,
          <span class="hljs-attr">size</span>: {
            <span class="hljs-attr">big</span>: <span class="hljs-string">"50g"</span>,
            <span class="hljs-attr">small</span>: <span class="hljs-string">"20g"</span>,
          },
        },
      },
    });
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursion</span>(<span class="hljs-params"></span>) </span>{
      parse.type=<span class="hljs-string">'fruit'</span>;
      parse.suchAS.name=<span class="hljs-string">'cucumber'</span>;
      parse.suchAS.info.price=<span class="hljs-string">'0.8元/kg'</span>;
      parse.suchAS.info.size.small=<span class="hljs-string">'70g'</span>; 
      parse.suchAS.info.size.big=<span class="hljs-string">'90g'</span>;
    }
    <span class="hljs-keyword">return</span> { parse,recursion };
  },
</div></code></pre>
<ul>
<li>当数据量庞大，需要考虑性能时
<ul>
<li>在&lt; <strong>什么是 <code>reactive</code></strong> &gt;中总结知道：
<ul>
<li><code>reactive</code>和<code>ref</code>通过递归取出参数中所有值，包装为<code>proxy</code>对象</li>
<li>递归的优与劣我总结过，涉及内存中的压栈和栈顶弹出等，建议回顾下👉<a href="https://juejin.cn/post/6870823876591517704">点击</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="%E9%9D%9E%E9%80%92%E5%BD%92%E7%9B%91%E5%90%AC"><strong>非递归监听</strong></h4>
<ul>
<li>上面知道了递归监听上的种种劣势，而<code>Vue3.0</code>也提供了解决方案
<ul>
<li>非递归监听，即：只监听数据的第一层。方案如下：
<ol>
<li>引入<code>Vue3.0</code>中提供的<code>shallowReactive</code></li>
<li>改用 <code>shallowReactive({})</code>传递参数</li>
<li>经过调试发现，只有第一层包装成了<code>proxy</code>对象，如下图
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07ca0d8188ec4eddb6259388acb8614b~tplv-k3u1fbpfcp-watermark.image" alt=""></li>
</ol>
</li>
<li>而对于<code>ref</code>对应的<code>shallowRef</code>非递归监听则比较特殊
<ol>
<li>首先试引入<code>Vue3.0</code>中官方提供的<code>shallowRef</code></li>
<li>原理上与<code>reactive</code>相同，只是它并不会监听<code>JSON</code>第一层数据</li>
<li>而是要直接修改<code>value</code>的值，这样视图才会同步更新</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursion</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">/** * shallowRef 对第一层修改不会监听，所以视图不变 */</span>
      parse.value.type=<span class="hljs-string">'fruit'</span>;
      parse.value.suchAS.name=<span class="hljs-string">'cucumber'</span>;
      parse.value.suchAS.info.price=<span class="hljs-string">'0.8元/kg'</span>;
      parse.value.suchAS.info.size.small=<span class="hljs-string">'70g'</span>; 
      parse.value.suchAS.info.size.big=<span class="hljs-string">'90g'</span>;
      <span class="hljs-comment">/** * 正确做法应该是整个修改 value */</span>
        parse.value = {
        <span class="hljs-attr">type</span>: <span class="hljs-string">"fruit"</span>,
        <span class="hljs-attr">suchAS</span>: {
          <span class="hljs-attr">name</span>: <span class="hljs-string">"cucumber"</span>,
          <span class="hljs-attr">info</span>: {
            <span class="hljs-attr">price</span>: <span class="hljs-string">"0.8元/kg"</span>,
            <span class="hljs-attr">size</span>: {
              <span class="hljs-attr">big</span>: <span class="hljs-string">"70g"</span>,
              <span class="hljs-attr">small</span>: <span class="hljs-string">"90g"</span>,
            },},},};}
</div></code></pre>
<blockquote>
<p>注意点：虽然他们只对第一层进行了监听，但若恰巧每次都更改了第一层数据，则也会引起下方数据和视图的同步更新，此时<code>shallowReactive</code>或者<code>shallowRef</code>就和<code>reactive、Ref</code>效果一模一样！</p>
</blockquote>
<h4 id="%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC%E8%A1%A5%E5%85%85"><strong>数据监听补充</strong></h4>
<ul>
<li>通过以上这些知识点可知：
<ul>
<li><code>ref</code>和<code>reactive</code>监听每一层数据，响应好但递归取值性能差。</li>
<li><code>shallowReactive</code>和<code>shallowRef</code>监听第一层（或value），性能好但更新值较麻烦</li>
<li><code>shallowRef</code>中，为了数据和视图一致，更新值要更新整个<code>parse.value</code>太繁琐</li>
<li>场景：若我更新数据的第三层，不整个更新<code>value</code>行不行？
<ol>
<li>这就用到了<code>Vue3.0</code>为<code>ref</code>准备的<code>triggerRef</code>(不用查啦 就一个)</li>
<li>作用：根据传入的数据，主动去更新视图
<ul>
<li>老规矩，<code>import {shallowRef, triggerRef } from &quot;vue&quot;</code></li>
<li>改完非首层的数据，而你使用的是<code>shallowRef</code>还不想整个更新<code>value</code></li>
<li>使用<code>triggerRef</code>大法，传入整个对象，就好啦</li>
<li>（使用<code>reactive</code>传入的数据，无法触发<code>triggerRef</code>）</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursion</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">/**
       *  方法一、手动更新
      parse.value = {
        type: "fruit",
        suchAS: {
          name: "cucumber",
          info: {
            price: "0.8元/kg",
            size: {
              big: "70g",
              small: "90g",
          },},},};
       */</span>
      <span class="hljs-comment">/** * 方法而、使用 triggerRef */</span>
      parse.value.suchAS.info.price=<span class="hljs-string">'0.8元/kg'</span>;
      triggerRef(parse)
    }
</div></code></pre>
<h4 id="%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F%E9%80%89%E6%8B%A9"><strong>数据监听方式选择</strong></h4>
<ul>
<li>正常数据量时，通常使用<code>ref</code>和<code>reactive</code>（递归监听）即可满足业务需要</li>
<li>当数据量庞大且注重性能时，就需考虑<code>shallowReactive</code>和<code>shallowRef</code>了（非递归监听）</li>
</ul>
<h4 id="shallowref%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><strong><code>shallowRef</code>底层原理</strong></h4>
<ul>
<li>在看 <code>ref</code> 时，我们知道它的本质其实是 <code>reactive({value:XX})</code></li>
<li>那么 <code>shallowRef</code> 其实是 <code>shallowReactive({value:XX})</code>
<ul>
<li>因为通过<code>shallowRef</code> 创建的数据，它监听的是 <code>.value</code> 的变化</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> state1=shallowRef({
    <span class="hljs-attr">a</span>:<span class="hljs-string">'a'</span>,
    <span class="hljs-attr">b</span>:{
      <span class="hljs-attr">b_1</span>:<span class="hljs-string">'b_1'</span>,
      <span class="hljs-attr">b_2</span>:<span class="hljs-string">'b_2'</span>
    }
  })
  <span class="hljs-comment">//--其实是如下所示</span>
  <span class="hljs-keyword">let</span> state2=shallowReactive({
    <span class="hljs-attr">value</span>:{
        <span class="hljs-attr">a</span>:<span class="hljs-string">'a'</span>,
        <span class="hljs-attr">b</span>:{
          <span class="hljs-attr">b_1</span>:<span class="hljs-string">'b_1'</span>,
          <span class="hljs-attr">b_2</span>:<span class="hljs-string">'b_2'</span>
        }
    }
  })
</div></code></pre>
<h4 id="toraw"><strong>toRaw</strong></h4>
<ul>
<li>在之前的知识体系中我们知道
<ul>
<li><code>setup</code> 中定义参数对象，在函数中直接修改页面是不会同步更新。</li>
<li>需要利用 <code>Ref</code> 或者 <code>reactive</code> 进行包装，这样修改才生效</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">let</span> obj={ <span class="hljs-attr">name</span>:<span class="hljs-string">'花花'</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">'3'</span>}
    <span class="hljs-keyword">let</span> test=reactive(obj);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFun</span>(<span class="hljs-params"></span>) </span>{test.name=<span class="hljs-string">'乐乐'</span>;}
</div></code></pre>
<ul>
<li>
<ul>
<li><code>obj</code> 和 <code>test</code>是引用关系</li>
<li><code>reactive</code> 会把传进来的参数包装为一个 <code>porxy</code> 对象并返回</li>
<li>例子中 <strong>test</strong> 本质是一个<code>porxy</code>对象，而这个对象也引用了 <code>obj</code>
<ul>
<li>那么请注意：
<ul>
<li>直接修改<code>obj</code>或引用的 <code>test</code> 都会引起内存中数据变化</li>
<li>但是修改 <code>obj</code>因为没有 <code>proxy</code>监听，所以视图不会更新</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>说了那么多，再绕回来说<code>toRaw</code>
<ul>
<li>作用：返回由 <code>reactive</code>  或<code> readonly</code> 等方法转换成响应式代理的普通对象</li>
<li>特点：<code>toRaw</code> 拿到的数据不会被监听变化，节省性能</li>
<li>场景：数据更改不需更新视图，为提高性能，通过 <code>toRaw</code> 拿到数据修改</li>
<li>提示：因为是原始数据，风险较大，一般不建议使用、</li>
<li>注意：若想拿到的是<code>Ref</code> 创建的对象，记得加 <strong>value</strong></li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>      <span class="hljs-keyword">let</span> obj={
        <span class="hljs-attr">name</span>:<span class="hljs-string">'花花'</span>,
        <span class="hljs-attr">age</span>:<span class="hljs-string">'3'</span>
      }
      <span class="hljs-keyword">let</span> testReactive=reactive(obj);
      <span class="hljs-keyword">let</span> testRef=ref(obj);
      <span class="hljs-keyword">let</span> rawReac=toRaw(testReactive);
      <span class="hljs-keyword">let</span> rawRef=toRaw(testRef.value);
      <span class="hljs-built_in">console</span>.log(rawReac===obj); <span class="hljs-comment">//true</span>
      <span class="hljs-built_in">console</span>.log(rawRef===obj); <span class="hljs-comment">//true</span>
</div></code></pre>
<h4 id="markraw"><strong>markRaw</strong></h4>
<ul>
<li>在之前的知识体系中我们知道</li>
<li>作用：固定某数据，不追踪它值的变化,同时视图也不会更新</li>
<li>通过控制台查看，使用<code>markRaw</code>的对象参数，被赋予<code>v_skip</code>监听跳过标识符</li>
</ul>
<pre class="hljs"><code><div>   <span class="hljs-keyword">let</span> obj={
       <span class="hljs-attr">name</span>:<span class="hljs-string">'poo'</span>,
       <span class="hljs-attr">age</span>:<span class="hljs-string">'3'</span>
   }
   <span class="hljs-built_in">console</span>.log(obj);<span class="hljs-comment">//{name: "poo", age: "3"}</span>
    obj=markRaw(obj)<span class="hljs-comment">//使其值的改变，不会被监听，视图不会发生变化</span>

   <span class="hljs-keyword">let</span> testReactive=reactive(obj);
   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFun</span>(<span class="hljs-params"></span>) </span>{
     testReactive.name=<span class="hljs-string">'地瓜'</span>;
     <span class="hljs-built_in">console</span>.log(obj);<span class="hljs-comment">//{name: "地瓜", age: "3", __v_skip: true}</span>
   }
</div></code></pre>
<h4 id="toref"><strong>toRef</strong></h4>
<ul>
<li><code>toRef</code>和<code>ref</code>一样，同样也是创建响应式数据的</li>
<li>先说结论：
<ul>
<li>1.<code>ref</code> 将对象中某属性变为响应式，修改时原数据不受影响</li>
<li>2.<code>toRef</code> 会改变原数据</li>
<li>3.并且 <code>toRef</code> 创建的数据，改变时界面不会自动更新</li>
</ul>
</li>
<li>应用场景：性能优化
<ul>
<li>想使创建的响应式数据与元数据关联起来</li>
<li>更新响应式数据后，不想更新UI</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  setup() {
      <span class="hljs-comment">/** * toRef */</span>
      <span class="hljs-keyword">let</span> obj={ <span class="hljs-attr">name</span>:<span class="hljs-string">'poo'</span> }
      <span class="hljs-keyword">let</span> obj2={<span class="hljs-attr">name</span>:<span class="hljs-string">'boo'</span>}
      <span class="hljs-comment">//-注意：这里是让 toRef 知道是让 obj里的 name变成响应式</span>
    <span class="hljs-keyword">let</span> test_toRef=toRef(obj,<span class="hljs-string">'name'</span>);
    <span class="hljs-keyword">let</span> test_ref=ref(obj2.name);
    <span class="hljs-built_in">console</span>.log(test_toRef);
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFun</span>(<span class="hljs-params"></span>) </span>{
      test_toRef.value=<span class="hljs-string">'土豆'</span>;
      test_ref.value=<span class="hljs-string">'地瓜'</span>;
      <span class="hljs-built_in">console</span>.log(obj,);<span class="hljs-comment">// {name: "土豆"}</span>
      <span class="hljs-built_in">console</span>.log(obj2);<span class="hljs-comment">// {name: "boo"}</span>
    }
    <span class="hljs-keyword">return</span> {obj,obj2, myFun };
  }
</div></code></pre>
<h4 id="torefs"><strong>toRefs</strong></h4>
<ul>
<li><code>toRef</code>只能接受两个参数，当传递某对象多个属性值时会很麻烦</li>
<li>结论：
<ul>
<li>1.<code>toRefs</code> 是避免 <code>toRef</code> 对多个属性操作繁琐</li>
<li>2.<code>toRefs</code> 底层原理是使用 <code>toRef</code> 方法遍历对象属性值</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  setup() {
      <span class="hljs-keyword">let</span> obj={
        <span class="hljs-attr">name</span>:<span class="hljs-string">'poo'</span>,
        <span class="hljs-attr">age</span>:<span class="hljs-string">'3'</span>
      }
    <span class="hljs-keyword">let</span> test_toRefs=toRefs(obj);
    <span class="hljs-comment">/**
     * 在 toRefs 底层中其实执行了以下遍历方法
     * let par1=toRef(obj,'name')
     * let par2=toRef(obj,'age')
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFun</span>(<span class="hljs-params"></span>) </span>{
      test_toRefs.name.value=<span class="hljs-string">'HAHA'</span>;
      test_toRefs.age.value=<span class="hljs-string">'13'</span>;
    }
    <span class="hljs-keyword">return</span> {test_toRefs, myFun };
  }
</div></code></pre>
<h4 id="%E5%9C%A8-vue30-%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-ref-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><strong>在 Vue3.0 中如何通过 ref 获取元素 ？</strong></h4>
<ul>
<li>在 Vue2.0版本内，通常使用 <code>this.$refs.XX</code> 获取元素</li>
<li>在Vue3.0中，废除了类似<code>$</code>的很多符号，如何获取指定元素 ？</li>
<li>根据Vue生命周期图中可知，要操作DOM，最早也要在<code>mounted</code>中</li>
<li>结论：
<ul>
<li>1.<code>setup</code> 是在<code>beforeCreate</code>之前执行</li>
<li>2.在生命周期中 <code>onMounted</code>最先准备好 <code>DOM</code>元素</li>
<li>3.<code>setup</code>中想操纵 <code>DOM</code> 就在函数中引用 <code>onMounted</code></li>
<li>4.<code>Vue3.0</code>中生命周期函数被抽离，可根据需要引入相应周期函数</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  setup() {
    <span class="hljs-keyword">let</span> btn=ref(<span class="hljs-literal">null</span>);
    <span class="hljs-built_in">console</span>.log(btn.value);
    <span class="hljs-comment">// 回调函数和它在函数中顺序无关，根据 Vue 生命周期顺序执行</span>
    onMounted(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
      <span class="hljs-built_in">console</span>.log(btn.value);<span class="hljs-comment">//-  &lt;button&gt;clickMe&lt;/button&gt;  </span>
    })
    <span class="hljs-keyword">return</span> {btn};
  },
</div></code></pre>
<h4 id="readonly"><strong>readonly</strong></h4>
<ul>
<li>Vue3.0中提供的这个API，使得数据被保护，只读不可修改</li>
<li>默认所有层数据都只读，若只限制第一层只读，可使用<code>shallowReadonly</code></li>
<li><code>isReadonly</code>用来检测数据创建来源是否是 <code>readonly</code></li>
<li>若进行修改，浏览器会提示操作失败，目标只读</li>
</ul>
<pre class="hljs"><code><div>  setup() {
    <span class="hljs-keyword">let</span> obj={
      <span class="hljs-attr">name</span>:<span class="hljs-string">'poo'</span>,
      <span class="hljs-attr">age</span>:<span class="hljs-string">'13'</span>
    }
    <span class="hljs-keyword">let</span> only=readonly(obj)
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFun</span>(<span class="hljs-params"></span>) </span>{
      only.name=<span class="hljs-string">'HAHA'</span>;<span class="hljs-comment">//  failed: target is readonly</span>
    }
    <span class="hljs-keyword">return</span> {only, myFun };
  }
</div></code></pre>
<h4 id="vue30%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E6%9C%AC%E8%B4%A8">** Vue3.0响应式数据本质**</h4>
<ul>
<li>2.0中使用的 <code>Object.defineProperty</code> 实现响应式数据</li>
<li>3.0中使用的 <code>Proxy</code> 来实现,如下</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">let</span> obj={
      <span class="hljs-attr">name</span>:<span class="hljs-string">'poo'</span>,
      <span class="hljs-attr">age</span>:<span class="hljs-string">'13'</span>
    }
    <span class="hljs-keyword">let</span> objProxy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj,{
      <span class="hljs-comment">//数据读会触发</span>
      <span class="hljs-keyword">get</span>(obj,key){
        <span class="hljs-built_in">console</span>.log(obj);<span class="hljs-comment">//{name: "poo", age: "13"}</span>
        <span class="hljs-keyword">return</span> obj[key]
      },
      <span class="hljs-comment">//监听的数据被修改会触发</span>
      <span class="hljs-keyword">set</span>(obj,key,value){
      <span class="hljs-comment">// 操作的对象，操作的属性，赋予的新值</span>
      obj[key]=value <span class="hljs-comment">//把外界赋予的新值更新到该对象</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'进行UI之类的操作'</span>);
      <span class="hljs-comment">//-补充，有时会多次操作，此时必须return true才不会影响下次操作</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    })
   objProxy.name;
</div></code></pre>
<h4 id="%E5%AE%9E%E7%8E%B0shallowreactive%E5%92%8Cshallowref"><strong>实现shallowReactive和shallowRef</strong></h4>
<ul>
<li>它们二者也是通过参数传递，包装成 <code>proxy</code> 对象进行监听</li>
<li>在 <code>Proxy</code> 的 <code>set</code> 监听中，同样只监听第一层</li>
<li><code>shallowRef</code> 只是在 <code>shallowReactive</code> 基础上默认添加 <code>value</code> 键名</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowReactive</span>(<span class="hljs-params">obj</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj,{
    <span class="hljs-keyword">get</span>(obj,key){
      <span class="hljs-keyword">return</span> obj[key]
    },
    <span class="hljs-keyword">set</span>(obj,key,value){
      obj[key]=value
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'更新'</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  })
}
<span class="hljs-keyword">let</span> obj={
  <span class="hljs-attr">A</span>:<span class="hljs-string">'A'</span>,
  <span class="hljs-attr">B</span>:{
    <span class="hljs-attr">b1</span>:<span class="hljs-string">'b1'</span>,
    <span class="hljs-attr">b2</span>:<span class="hljs-string">'b2'</span>,
    <span class="hljs-attr">b3</span>:{
      <span class="hljs-attr">b3_1</span>:<span class="hljs-string">'b3-1'</span>,
      <span class="hljs-attr">b3_2</span>:<span class="hljs-string">'b3-2'</span>
    } } }
<span class="hljs-keyword">let</span> test=shallowReactive(obj)
<span class="hljs-comment">//-这里同样只会监听第一层</span>
test.A=<span class="hljs-string">'apple'</span>;
test.B.b2=<span class="hljs-string">'banana'</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowRef</span>(<span class="hljs-params">obj</span>)</span>{
  <span class="hljs-keyword">return</span> shallowReactive(obj,{<span class="hljs-attr">value</span>:vl})
}
<span class="hljs-keyword">let</span> state=shallowRef(obj);
</div></code></pre>
<h4 id="%E5%AE%9E%E7%8E%B0-reactive-%E5%92%8C-ref"><strong>实现 reactive 和 ref</strong></h4>
<ul>
<li>它们与上方区别在于递归监听</li>
<li>上方因为直接传递参数对象，所以只监听第一层</li>
<li>为了递归监听，那么要把数据的每一层都给包装成 <code>Proxy</code>对象</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactive</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">"object"</span>) {
    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {
      <span class="hljs-comment">//当前参数为数组类型，则循环取出每一项</span>
      obj.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">"object"</span>) {
          <span class="hljs-comment">//分析数组每一项，是对象则递归</span>
          obj[index] = reactive(item);
        }
      });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 当前参数是对象且不是数组，则取属性值并进行分析是否是多层对象</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">"object"</span>) {
          obj[key] = reactive(item);
        }
      }
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"当前传入为非对象参数"</span>);
  }
  <span class="hljs-comment">//-正常情况下就进行 Proxy对象包装</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {
    <span class="hljs-keyword">get</span>(obj, key) {
      <span class="hljs-keyword">return</span> obj[key];
    },
    <span class="hljs-keyword">set</span>(obj, key, value) {
      obj[key] = value;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"更新"</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    },
  });
}
</div></code></pre>
<h4 id="%E5%AE%9E%E7%8E%B0-shallowreadonly-%E5%92%8C-readonly"><strong>实现 shallowReadonly 和 readonly</strong></h4>
<ul>
<li>二者区别只在于首层监听，只读拒绝修改和数据全层修改</li>
<li>下方实现的是 <code>shallowReadonly</code></li>
<li><code>readonly</code> 实现是在 <code>shallowReadonly</code> 基础上移除<code>set</code> 中的<code>return true</code></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowReadonly</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, {
    <span class="hljs-keyword">get</span>(obj, key) {
      <span class="hljs-keyword">return</span> obj[key];
    },
    <span class="hljs-keyword">set</span>(obj, key, value) {
      <span class="hljs-comment">// obj[key] = value;</span>
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`<span class="hljs-subst">${key}</span>为只读，不可修改-`</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//此行移除，则就是 readonly 全层数据只读</span>
    },
  });
}
<span class="hljs-keyword">let</span> parse = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">"fruit"</span>,
  <span class="hljs-attr">suchAS</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">"cucumber"</span>,
  },
};
<span class="hljs-keyword">let</span> fakeShowRe=shallowReadonly(parse);
fakeShowRe.type=<span class="hljs-string">'HAHA'</span>;<span class="hljs-comment">// 此时修改不会生效</span>
fakeShowRe.suchAS.name=<span class="hljs-string">'HAHA'</span>;<span class="hljs-comment">// 非首层修改会生效</span>
</div></code></pre>

</body>
</html>
